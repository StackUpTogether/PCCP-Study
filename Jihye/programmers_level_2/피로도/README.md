# 피로도

> 🔗 문제 링크: [바로가기](https://school.programmers.co.kr/learn/courses/30/lessons/87946) 

## 🌱 문제 설명
게임에는 피로도 시스템 (0 이상의 정수로 표현)이 있으며, 일정 피로도를 사용해서 던전을 탐험할 수 있다. 이 때, 각 던전마다 탐험을 시작하기 위해 필요한 `최소 필요 피로도`와 던전 탐색을 마쳤을 때 소모되는 `소모 피로도`가 있다. `최소 필요 피로도`는 해당 던전을 탐험하기 위해 가지고 있어야 하는 최소한의 피로도를 나타내며, `소모 피로도`는 던전을 탐험한 후 소모되는 피로도를 나타낸다. 예를 들어 `최소 필요 피로도`가 80, `소모 피로도`가 20인 던전을 탐험하기 위해서는 유저의 현재 남은 피로도는 80 이상 이어야 하며, 던전을 탐험한 후에는 피로도 20이 소모된다.

이 게임에는 하루에 한 번씩 탐험할 수 있는 던전이 여러개 있는데, 이 던전들을 최대한 많이 탐험하려 한다. 유저의 현재 피로도 k와 각 던전별 `최소 필요 피로도`, `소모 피로도`가 담긴 2차원 배열 dungeons가 매개변수로 주어질 때, 유저가 탐험할 수 있는 최대 던전 수를 return 하는 함수를 작성하는 문제.

단, 제한사항은 아래와 같다.

- k는 1 이상 5,000 이하인 자연수이다.
- dungeons의 세로(행) 길이(즉, 던전의 개수)는 1 이상 8 이하이다.
  - dungeons의 가로(열) 길이는 2 이다.
  - dungeons의 각 행은 각 던전의 [`최소 필요 피로도`, `소모 피로도`] 이다.
  - `최소 필요 피로도`는 항상 `소모 피로도`보다 크거나 같다.
  - `최소 필요 피로도`와 `소모 피로도`는 1 이상 1,000 이하인 자연수이다.
  - 서로 다른 던전의 [`최소 필요 피로도`, `소모 피로도`]가 서로 같을 수 있다.


## 🤔 접근 방식
- 완전탐색 깊이우선탐색인 DFS 방식으로 모든 경우의 수 확인.

## 💡 주요 포인트
- 방문여부를 확인하는 배열 `visited`를 작성한다.
  ```js
  let visited = Array(dungeons.length).fill(false);
  ```
- dfs를 작성할 때, for문 내부에서 방문을 확인하고, 방문이 안 되었는데 `최소 필요 피로도`보다 남아 있는 유저의 피로도가 높으면 방문처리 후 dfs로 넣어준다.
  ```js
  let dfs = (kLeft, count) => {
    for (let i = 0; i < dungeons.length; i++) {
      if (!visited[i] && kLeft >= dungeons[i][0]) {
        visited[i] = true;
        dfs(kLeft - dungeons[i][1], count + 1);
        visited[i] = false;
      }
    }
    if (maxCount < count) {
      maxCount = count;
    }
  };
  ```
  visited 배열은 다시 false로 백트래킹을 해 주어 다음 반복 시 사용 가능하도록 하며, 반복문 종료 후 maxCount와 비교하여 count가 더 큰 경우 maxCount에 저장해준다.