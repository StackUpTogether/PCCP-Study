# 모의고사

> 🔗 문제 링크: [바로가기](https://school.programmers.co.kr/learn/courses/30/lessons/42840) 

## 🌱 문제 설명
수포자 삼인방은 모의고사에 수학 문제를 전부 찍으려 한다. 각각 다음과 같이 찍는다.

- 1번 수포자가 찍는 방식: 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, ...
- 2번 수포자가 찍는 방식: 2, 1, 2, 3, 2, 4, 2, 5, 2, 1, 2, 3, 2, 4, 2, 5, ...
- 3번 수포자가 찍는 방식: 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, ...

1번 문제부터 마지막 문제까지의 정답이 순서대로 들은 배열 answers가 주어졌을 때, 가장 많은 문제를 맞힌 사람이 누구인지 배열에 담아 return 하는 함수를 작성하는 문제.

단, 제한 조건은 다음과 같다.

- 시험은 최대 10,000 문제로 구성되어있다.
- 문제의 정답은 1, 2, 3, 4, 5 중 하나이다.
- 가장 높은 점수를 받은 사람이 여럿일 경우, return 하는 값을 오름차순 정렬한다.

## 🤔 접근 방식
- 문제가 10,000개밖에 없기 때문에 완전탐색 방식으로 해결

## 💡 주요 포인트
- 수포자들이 정답을 찍는 방식을 배열로 작성
  ```js
  let first = [1, 2, 3, 4, 5];
  let second = [2, 1, 2, 3, 2, 4, 2, 5];
  let third = [3, 3, 1, 1, 2, 2, 4, 4, 5, 5];
  ```
- 각 수포자가 정답을 맞춘 갯수를 저장할 이차원 배열 작성
  ```js
  let count = [
    [1, 0],
    [2, 0],
    [3, 0],
  ];
  ```
- for문을 하나만 사용하기 위해 내부에서 if문을 3번 사용하여 각각의 수포자가 정답을 맞춘 경우만 count의 개수를 증가
  ```js
  for (let j = 0; j < answers.length; j++) {
    if (answers[j] === first[j % 5]) {
      count[0][1] += 1;
    }
    if (answers[j] === second[j % 8]) {
      count[1][1] += 1;
    }
    if (answers[j] === third[j % 10]) {
      count[2][1] += 1;
    }
  }
  ```
- 맞춘 갯수를 기준으로 내림차순으로 정렬하여 맨 앞부터 최댓값인지 확인, 아닌 경우 같은 갯수를 맞춘 수포자 번호를 오름차순으로 정렬하여 반환.

